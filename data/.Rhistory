colnames(results_df) = c("Simulation", "n", "Intercept", "Slope", "InterceptSE", "SlopeSE")
# Loop over the values of n and call the function
for (i in seq_along(n_values)) {
n = n_values[i] # run simulation for n data-points
result = my_function(0, 5, n, 20) # generate data
lm_fit <- lm(result$y ~ result$x) # create regression
coefficients <- summary(lm_fit)$coefficients[, 1] # extract coefficients
se <- summary(lm_fit)$coefficients[, 2] # extract SE's for coefficients
results_df[i, ] <- c(paste0("Simulation_", i), n, coefficients, se)
}
# Convert relevant columns to numeric class
results_df <- results_df %>%
mutate_at(vars(2:6), as.numeric)
# Graph coefficients SE's as a function of n
results_df %>% ggplot(aes(x = n, y = InterceptSE)) +
geom_point()
results_df %>% ggplot(aes(x = n, y = SlopeSE)) +
geom_point()
# Graph coefficients SE's as a function of n
results_df %>% ggplot(aes(x = n, y = InterceptSE)) +
geom_point()
results_df %>% ggplot(aes(x = n, y = SlopeSE)) +
geom_point()
results_df %>% ggplot(aes(x = n, y = Intercept)) +
geom_point()
results_df %>% ggplot(aes(x = n, y = Slope)) +
geom_point()
# Loading the data
remotes::install_github("avehtari/ROS-Examples",subdir = "rpackage")
library(rosdata)
?rss()
?rss
rss <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(resid^2))
}
rss <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(resid^2))
}
rss(hibbs$growth, hibbs$vote, a, 3)
rss(hibbs$growth, hibbs$vote, 2, 3)
rss(hibbs$growth, hibbs$vote, 46, 3)
rss(hibbs$growth, hibbs$vote, 47, 3)
rss(hibbs$growth, hibbs$vote, 48, 3)
rss(hibbs$growth, hibbs$vote, 35, 3)
rss(hibbs$growth, hibbs$vote, 38, 3)
rss(hibbs$growth, hibbs$vote, 46, 3)
rss(hibbs$growth, hibbs$vote, 46,3, 3)
rss(hibbs$growth, hibbs$vote, 46.3, 3)
a <- seq(1:100)
for i (in a) {
for a (in a) {
for i (in a) {
rss <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(resid^2))
}
a <- seq(1:100)
for i (in a) {
data <- data.frame(x = numeric(length(a)), y = numeric(length(a)))
rss_function_df <- data.frame(x = numeric(length(a)), y = numeric(length(a)))
for (i in a) {
residual = rss(hibbs$growth, hibbs$vote, a, 3)
data$x[i] = i
data$y[i] = residual
}
rss <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(resid^2))
}
a <- seq(1:100)
rss_function_df <- data.frame(x = numeric(length(a)), y = numeric(length(a)))
for (i in a) {
residual <-  rss(hibbs$growth, hibbs$vote, i, 3)
data$x[i] <-  i
data$y[i] <-  residual
}
View(data)
a <- seq(1:100, by 0.1)
rss <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(resid^2))
}
a <- seq(1, 100, by = 0.1)
rss_function_df <- data.frame(x = numeric(length(a)), y = numeric(length(a)))
for (i in a) {
residual <-  rss(hibbs$growth, hibbs$vote, i, 3)
data$x[i] <-  i
data$y[i] <-  residual
}
View(data)
for (i in a) {
residual <-  rss(hibbs$growth, hibbs$vote, i, 3)
data$x[i] <-  i
data$y[i] <-  residual
}
rss <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(resid^2))
}
a <- seq(1, 100, by = 0.1)
data <- data.frame(x = numeric(length(a)), y = numeric(length(a)))
for (i in a) {
residual <-  rss(hibbs$growth, hibbs$vote, i, 3)
data$x[i] <-  i
data$y[i] <-  residual
}
View(data)
rss <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(resid^2))
}
a <- seq(1, 100, by = 0.1)
data <- data.frame(x = numeric(length(a)), y = numeric(length(a)))
for (i in seq_along(a)) {
residual <- rss(hibbs$growth, hibbs$vote, a[i], 3)
data$x[i] <-  a[i]
data$y[i] <-  residual
}
View(data)
data %>% ggplot(aes(x = data$x, y = data$y)) %>%
geom_point()
data %>% ggplot(aes(x = data$x, y = data$y)) +
geom_point()
data %>% ggplot(aes(x = data$x, y = data$y)) +
geom_line()
rss <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(resid^2))
}
a <- seq(1, 100, by = 0.1)
data <- data.frame(x = numeric(length(a)), y = numeric(length(a)))
for (i in seq_along(a)) {
residual <- rss(hibbs$growth, hibbs$vote, a[i], 3)
data$x[i] <-  a[i]
data$y[i] <-  residual
}
data %>% ggplot(aes(x = data$x, y = data$y)) +
geom_line() +
xlab(Intercept Value (a)) +
rss <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(resid^2))
}
a <- seq(1, 100, by = 0.1)
data <- data.frame(x = numeric(length(a)), y = numeric(length(a)))
for (i in seq_along(a)) {
residual <- rss(hibbs$growth, hibbs$vote, a[i], 3)
data$x[i] <-  a[i]
data$y[i] <-  residual
}
data %>% ggplot(aes(x = data$x, y = data$y)) +
geom_line() +
xlab("Intercept Value (a)") +
ylab("Residual Sum of Squares")
print(min(data$y))
rss <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(resid^2))
}
a <- seq(1, 100, by = 0.1)
data <- data.frame(x = numeric(length(a)), y = numeric(length(a)))
for (i in seq_along(a)) {
residual <- rss(hibbs$growth, hibbs$vote, a[i], 3)
data$x[i] <-  a[i]
data$y[i] <-  residual
}
data %>% ggplot(aes(x = data$x, y = data$y)) +
geom_line() +
xlab("Intercept Value (a)") +
ylab("Residual Sum of Squares")
print(min(data$y))
optim(0, rss, method = "CG")
optim(par = 0, x = data$x, y = data$y, b = 3, rss, method = "CG")
optim(par = 20, x = data$x, y = data$y, b = 3, rss, method = "CG")
rss <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(resid^2))
}
a <- seq(1, 100, by = 0.1)
data <- data.frame(x = numeric(length(a)), y = numeric(length(a)))
for (i in seq_along(a)) {
residual <- rss(hibbs$growth, hibbs$vote, a[i], 3)
data$x[i] <-  a[i]
data$y[i] <-  residual
}
data %>% ggplot(aes(x = data$x, y = data$y)) +
geom_line() +
xlab("Intercept Value (a)") +
ylab("Residual Sum of Squares")
print(min(data$y))
optim(par = 20, x = data$x, y = data$y, b = 3, rss, method = "CG")
optim(par = 40, x = data$x, y = data$y, b = 3, rss, method = "CG")
optim(par = 43, x = data$x, y = data$y, b = 3, rss, method = "CG")
?optim()
optim(par = 43, x = data$x, y = data$y, b = 3, rss, method = "BFGS" )
print(min(data$y))
rss <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(resid^2))
}
a <- seq(1, 100, by = 0.1)
data <- data.frame(x = numeric(length(a)), y = numeric(length(a)))
for (i in seq_along(a)) {
residual <- rss(hibbs$growth, hibbs$vote, a[i], 3)
data$x[i] <-  a[i]
data$y[i] <-  residual
}
data %>% ggplot(aes(x = data$x, y = data$y)) +
geom_line() +
xlab("Intercept Value (a)") +
ylab("Residual Sum of Squares")
print(min(data$y))
data %>% select(y = 198.4022)
data %>%
filter(near(y, 198.4, tol = 0.05))
data %>%
filter(near(y, min(data$y), tol = 0.05))
data %>%
filter(near(y, min(data$y), tol = 0.01))
data %>%
filter(near(y, min(data$y), tol = 0.001))
rss <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(resid^2))
}
a <- seq(1, 100, by = 0.1)
data <- data.frame(x = numeric(length(a)), y = numeric(length(a)))
for (i in seq_along(a)) {
residual <- rss(hibbs$growth, hibbs$vote, a[i], 3)
data$x[i] <-  a[i]
data$y[i] <-  residual
}
data %>% ggplot(aes(x = data$x, y = data$y)) +
geom_line() +
xlab("Intercept Value (a)") +
ylab("Residual Sum of Squares")
data %>%
filter(near(y, min(data$y), tol = 0.001))
sum_abs_res <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(abs(resid)))
}
a <- seq(1, 100, by = 0.1)
a <- seq(1, 100, by = 0.1)
data <- data.frame(x = numeric(length(a)), y = numeric(length(a)))
theta <- c(0,0)
?optim()
optim(par = theta, fn = sum_abs_res)
rss <- function(x, y, a, b){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(resid^2))
}
a <- seq(1, 100, by = 0.1)
data <- data.frame(x = numeric(length(a)), y = numeric(length(a)))
for (i in seq_along(a)) {
residual <- rss(hibbs$growth, hibbs$vote, a[i], 3)
data$x[i] <-  a[i]
data$y[i] <-  residual
}
data %>% ggplot(aes(x = data$x, y = data$y)) +
geom_line() +
xlab("Intercept Value (a)") +
ylab("Residual Sum of Squares")
data %>%
filter(near(y, min(data$y), tol = 0.001))
optim(par = theta, fn = sum_abs_res, x = hibbs$growth, y = hibbs$vote)
optim(par = theta, fn = sum_abs_res, x = hibbs$growth, y = hibbs$vote)
sum_abs_res <- function(theta, x, y){ # x and y are vectors, a and b are scalars
resid <- y - (a + b*x)
return(sum(abs(resid)))
}
resid <- y - (theta[1] + theta[2]*x)
sum_abs_res <- function(theta, x, y){ # x and y are vectors, a and b are scalars
resid <- y - (theta[1] + theta[2]*x)
return(sum(abs(resid)))
}
theta <- c(0,0)
optim(par = theta, fn = sum_abs_res, x = hibbs$growth, y = hibbs$vote)
optim(par = theta, fn = sum_abs_res, x = hibbs$growth, y = hibbs$vote, method = "CG")
optim(par = theta, fn = sum_abs_res, x = hibbs$growth, y = hibbs$vote, method = "BFGS")
optim(par = theta, fn = sum_abs_res, x = hibbs$growth, y = hibbs$vote, method = "BFGS")
optim(par = theta, fn = sum_abs_res, x = hibbs$growth, y = hibbs$vote, method = "Brent")
optim(par = theta, fn = sum_abs_res, x = hibbs$growth, y = hibbs$vote, method = "Nelder-Mead")
optim(par = theta, fn = sum_abs_res, x = hibbs$growth, y = hibbs$vote, method = "CG")
# Visualize
a <- seq(40,50,by=.25)
b <- seq(0,10,by=.25)
z <- outer(x,y,sum_abs_res(a,b, x = hibbs$growth, y = hibbs$vote)) #All possible combination of x,y is used to calculate all possible f(x,y) = z.
# Visualize
a <- seq(40,50,by=.25)
b <- seq(0,10,by=.25)
z <- outer(a,b,sum_abs_res(a,b, x = hibbs$growth, y = hibbs$vote)) #All possible combination of x,y is used to calculate all possible f(x,y) = z.
# Visualize
x <- seq(40,50,by=.25)
y <- seq(0,10,by=.25)
z <- outer(x,y,sum_abs_res(x,y, x = hibbs$growth, y = hibbs$vote)) #All possible combination of x,y is used to calculate all possible f(x,y) = z.
# Find minima for sum_abs_res using optim
opt_res <- optim(par = theta, fn = sum_abs_res, x = hibbs$growth, y = hibbs$vote, method = "CG")
opt_res
# Visualize
x <- seq(40,50,by=.25)
y <- seq(0,10,by=.25)
z <- outer(x,y,function(x,y) sum_abs_res(c(opt_res$par[1], opt_res$par[2]), x = hibbs$growth, y = hibbs$vote))
# Plot 3D
persp(x,y,z,phi=45,theta=-45,col="green",shade=.00000001,ticktype="detailed")
z <- outer(x,y,function(x,y) sum_abs_res(c(opt_res$par[1], opt_res$par[2]), x = hibbs$growth, y = hibbs$vote))
z <- outer(x,y,sum_abs_res(c(opt_res$par[1], opt_res$par[2]), x = hibbs$growth, y = hibbs$vote))
opt_res
# Define function
sum_abs_res <- function(theta, x, y){ # x and y are vectors, a and b are scalars
resid <- y - (theta[1] + theta[2]*x)
return(sum(abs(resid)))
}
# Define starting vector (values for a and b)
theta <- c(0,0)
# Find minima for sum_abs_res using optim
opt_res <- optim(par = theta, fn = sum_abs_res, x = hibbs$growth, y = hibbs$vote, method = "CG")
print(opt_res)
knitr::opts_chunk$set(echo = TRUE)
?rnorm()
```{r}
data <- tibble(y = rnorm(10000))
quantile(data$y)
data %>%
ggplot(aes(sample = y)) +
geom_qq(size = .5) +
geom_qq_line(linetype = 3) +
theme_minimal()
data %>%
ggplot(aes(x = y)) +
geom_histogram(aes(y=..density..),fill = "steelblue") + #density instead of count
stat_function(fun = dnorm, args= list(mean = mean(data$y), sd = sd(data$y))) + # + curve
xlab("label") +
ylab("label") +
theme_minimal()
data %>%
ggplot(aes(sample = y)) +
geom_qq(size = .5) +
geom_qq_line(linetype = 3) +
theme_minimal()
data %>%
ggplot(aes(x = y)) +
geom_histogram(aes(y=..density..),fill = "steelblue") + #density instead of count
stat_function(fun = dnorm, args= list(mean = mean(data$y), sd = sd(data$y))) + # + curve
xlab("label") +
ylab("label") +
theme_minimal()
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(rstanarm)
library(bayesplot)
library(RColorBrewer)
colours <- brewer.pal(n = 8, name = 'Set1')
set.seed(0)
data <- tibble(y = rnorm(10000))
quantile(data$y)
data %>%
ggplot(aes(sample = y)) +
geom_qq(size = .5) +
geom_qq_line(linetype = 3) +
theme_minimal()
data %>%
ggplot(aes(x = y)) +
geom_histogram(aes(y=..density..),fill = "steelblue") + #density instead of count
stat_function(fun = dnorm, args= list(mean = mean(data$y), sd = sd(data$y))) + # + curve
xlab("label") +
ylab("label") +
theme_minimal()
n <- 10
const <- rep(1,n)
x <- 1:10
X <- cbind(const, x)
X
b <- c(2, 0.5)
b
ystar <- X %*% b
tibble(x, ystar) %>%
ggplot(aes(x = x, y = ystar)) +
geom_abline(intercept = b[1], slope = b[2]) +
geom_point(colour = colours[2]) +
coord_fixed(xlim = c(0,10), ylim = c(0,10)) +
labs(y = "y")# +
#scale_colour_brewer(palette = "Set1")
set.seed(0)
err = rnorm(10)
err
y <- X %*% b + err
y
data <- tibble(x = X[,2], y = y[,1])
data
bind_rows(data, bind_cols(x = x, y = ystar[,1]), .id = "noise") %>%
ggplot(aes(x = x, y = y, colour = factor(noise, labels = c("y", "ystar")))) +
geom_abline(intercept = b[1], slope = b[2]) +
geom_point() +
coord_fixed(xlim = c(0,10), ylim = c(0,10)) +
labs(colour = "Noise") +
scale_colour_brewer(palette = "Set1")
ggplot(data, aes(x = x, y = y)) +
geom_point(colour = colours[1]) +
geom_abline(intercept = b[1], slope = b[2]) +
#geom_abline(intercept = bhat[1], slope = bhat[2], colour = colours[1]) +
coord_fixed(xlim = c(0,10), ylim = c(0,10))
# Your solution goes here
b <- c(2.375, 0.005)
sigma <- 0.4
# Your solution goes here
# Your solution goes here
mcmc_areas(fit1, pars = "(Intercept)", prob = 0.5, prob_outer = 1)
n <- 10
const <- rep(1,n)
x <- 1:10
X <- cbind(const, x)
X
View(X)
b <- c(2, 0.5)
b
ystar <- X %*% b
View(ystar)
tibble(x, ystar) %>%
ggplot(aes(x = x, y = ystar)) +
geom_abline(intercept = b[1], slope = b[2]) +
geom_point(colour = colours[2]) +
coord_fixed(xlim = c(0,10), ylim = c(0,10)) +
labs(y = "y")# +
```{r}
set.seed(0)
err = rnorm(10)
err
y <- X %*% b + err
y
data <- tibble(x = X[,2], y = y[,1])
data
bind_rows(data, bind_cols(x = x, y = ystar[,1]), .id = "noise") %>%
ggplot(aes(x = x, y = y, colour = factor(noise, labels = c("y", "ystar")))) +
geom_abline(intercept = b[1], slope = b[2]) +
geom_point() +
coord_fixed(xlim = c(0,10), ylim = c(0,10)) +
labs(colour = "Noise") +
scale_colour_brewer(palette = "Set1")
First we generate a tibble with one column containing values drawn from the standard Gaussian distribution $\mathcal{N}(0,1)$.
```{r}
data <- tibble(y = rnorm(10000))
quantile(data$y)
data %>%
ggplot(aes(sample = y)) +
geom_qq(size = .5) +
geom_qq_line(linetype = 3) +
theme_minimal()
data %>%
ggplot(aes(x = y)) +
geom_histogram(aes(y=..density..),fill = "steelblue") + #density instead of count
stat_function(fun = dnorm, args= list(mean = mean(data$y), sd = sd(data$y))) + # + curve
xlab("label") +
ylab("label") +
theme_minimal()
First, we construct the design matrix $\mathrm{X}$.
Then we choose the coefficient vector $\boldsymbol{\beta}$.
```{r}
b <- c(2, 0.5)
b
tibble(x, ystar) %>%
ggplot(aes(x = x, y = ystar)) +
geom_abline(intercept = b[1], slope = b[2]) +
geom_point(colour = colours[2]) +
coord_fixed(xlim = c(0,10), ylim = c(0,10)) +
labs(y = "y")# +
set.seed(0)
err = rnorm(10)
err
y <- X %*% b + err
y
The OLS estimator gives us the estimate $\hat{\boldsymbol{\beta}}$ for $\boldsymbol{\beta}$ as a function of $\mathrm{X}$ and $\mathbf{y}$.
data <- tibble(y = rnorm(10000))
data <- tibble(y = rnorm(10000))
```{r}
quantile(data$y)
data %>%
ggplot(aes(sample = y)) +
geom_qq(size = .5) +
geom_qq_line(linetype = 3) +
theme_minimal()
ggplot(data, aes(x = x, y = y)) +
geom_point(colour = colours[1]) +
geom_abline(intercept = b[1], slope = b[2]) +
#geom_abline(intercept = bhat[1], slope = bhat[2], colour = colours[1]) +
coord_fixed(xlim = c(0,10), ylim = c(0,10))
library(tidyverse)
setwd("C:/Users/jonat/OneDrive/Desktop/University/Assignments/2. Semester/Applied Cognitive Science/Repository/applied-social-science")
setwd("/Users/jacoblillelund/Documents/applied-social-science")
wdb <- read_csv("/data/worlddatabank_clean.csv")
wdb <- read_csv("data/worlddatabank_clean.csv")
setwd()
wdb <- read_csv("/data/worlddatabank_clean.csv")
setwd("/Users/jacoblillelund/Documents/applied-social-science/data")
wdb <- read_csv("data/worlddatabank_clean.csv")
wdb <- read_csv("/data/worlddatabank_clean.csv")
wdb <- read_csv(/data/"worlddatabank_clean.csv")
wdb <- read_csv(select_file)
knitr::opts_knit$set(root.dir = "/Users/jacoblillelund/Documents/applied-social-science")
knitr::opts_knit$set(root.dir = "/Users/jacoblillelund/Documents/applied-social-science")
wdb <- read_csv("data/worlddatabank.csv")
unique <- unique(na.omit(is.numeric(wdb[0,])))
View(wdb)
economic_variables <- unique(na.omit(WDB[,2], ))
missing_data <- data_frame(economic_variable = economic_variables
)
unique <- unique(na.omit(is.numeric(wdb[0,])))
economic_variables <- unique(na.omit(WDB[,2], ))
economic_variables <- unique(na.omit(wdb[,2], ))
unique <- unique(na.omit(is.numeric(wdb[0,])))
